#!/bin/bash

# Created by argbash-init v2.8.1
# ARG_POSITIONAL_SINGLE([pod],[Pod name],[])
# ARG_OPTIONAL_SINGLE([local-dropbear-path],[l],[Local Path to statically-built dropbear/SSH server binary],[static-dropbear])
# ARG_OPTIONAL_SINGLE([remote-dropbear-dir],[r],[Pod Path to upload dropbear/SSH server to],[/tmp])
# ARG_OPTIONAL_SINGLE([bind-port],[b],[Pod Bind Port for dropbear/SSH server to],[22])
# ARG_OPTIONAL_SINGLE([authorized-keys-path],[k],[Public keys of those authorized to authenticate through SSH],[id_rsa.pub])
# ARG_OPTIONAL_SINGLE([ssh-path],[S],[SSH Path Location, specify if authenticate using non-root user],[/root/.ssh])
# ARG_OPTIONAL_SINGLE([namespace],[n],[Pod Namespace],[])
# ARG_OPTIONAL_BOOLEAN([cleanup],[c],[Cleanup all the files and dropbear binary before script exits])
# ARG_OPTIONAL_BOOLEAN([verbose],[V],[Increase verbosity of script])
# ARG_DEFAULTS_POS()
# ARG_HELP([kssh - Start a SSH server in any Pod])
# ARG_VERSION([echo $0 v0.1])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}


begins_with_short_option()
{
  local first_option all_short_options='lrbkSncVhv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_pod=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_local_dropbear_path="static-dropbear"
_arg_remote_dropbear_dir="/tmp"
_arg_bind_port="22"
_arg_authorized_keys_path="id_rsa.pub"
_arg_ssh_path="/root/.ssh"
_arg_namespace=
_arg_cleanup="off"
_arg_verbose="off"


print_help()
{
  printf '%s\n' "kssh - Start a SSH server in any Pod"
  printf 'Usage: %s [-l|--local-dropbear-path <arg>] [-r|--remote-dropbear-dir <arg>] [-b|--bind-port <arg>] [-k|--authorized-keys-path <arg>] [-S|--ssh-path <arg>] [-n|--namespace <arg>] [-c|--(no-)cleanup] [-V|--(no-)verbose] [-h|--help] [-v|--version] <pod>\n' "$0"
  printf '\t%s\n' "<pod>: Pod name"
  printf '\t%s\n' "-l, --local-dropbear-path: Local Path to statically-built dropbear/SSH server binary (default: 'static-dropbear')"
  printf '\t%s\n' "-r, --remote-dropbear-dir: Pod Path to upload dropbear/SSH server to (default: '/tmp')"
  printf '\t%s\n' "-b, --bind-port: Pod Bind Port for dropbear/SSH server to (default: '22')"
  printf '\t%s\n' "-k, --authorized-keys-path: Public keys of those authorized to authenticate through SSH (default: 'id_rsa.pub')"
  printf '\t%s\n' "-S, --ssh-path: SSH Path Location, specify if authenticate using non-root user (default: '/root/.ssh')"
  printf '\t%s\n' "-n, --namespace: Pod Namespace (no default)"
  printf '\t%s\n' "-c, --cleanup, --no-cleanup: Cleanup all the files and dropbear binary before script exits (off by default)"
  printf '\t%s\n' "-V, --verbose, --no-verbose: Increase verbosity of script (off by default)"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -l|--local-dropbear-path)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_local_dropbear_path="$2"
        shift
        ;;
      --local-dropbear-path=*)
        _arg_local_dropbear_path="${_key##--local-dropbear-path=}"
        ;;
      -l*)
        _arg_local_dropbear_path="${_key##-l}"
        ;;
      -r|--remote-dropbear-dir)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_remote_dropbear_dir="$2"
        shift
        ;;
      --remote-dropbear-dir=*)
        _arg_remote_dropbear_dir="${_key##--remote-dropbear-dir=}"
        ;;
      -r*)
        _arg_remote_dropbear_dir="${_key##-r}"
        ;;
      -b|--bind-port)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_bind_port="$2"
        shift
        ;;
      --bind-port=*)
        _arg_bind_port="${_key##--bind-port=}"
        ;;
      -b*)
        _arg_bind_port="${_key##-b}"
        ;;
      -k|--authorized-keys-path)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_authorized_keys_path="$2"
        shift
        ;;
      --authorized-keys-path=*)
        _arg_authorized_keys_path="${_key##--authorized-keys-path=}"
        ;;
      -k*)
        _arg_authorized_keys_path="${_key##-k}"
        ;;
      -S|--ssh-path)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_ssh_path="$2"
        shift
        ;;
      --ssh-path=*)
        _arg_ssh_path="${_key##--ssh-path=}"
        ;;
      -S*)
        _arg_ssh_path="${_key##-S}"
        ;;
      -n|--namespace)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_namespace="$2"
        shift
        ;;
      --namespace=*)
        _arg_namespace="${_key##--namespace=}"
        ;;
      -n*)
        _arg_namespace="${_key##-n}"
        ;;
      -c|--no-cleanup|--cleanup)
        _arg_cleanup="on"
        test "${1:0:5}" = "--no-" && _arg_cleanup="off"
        ;;
      -c*)
        _arg_cleanup="on"
        _next="${_key##-c}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -V|--no-verbose|--verbose)
        _arg_verbose="on"
        test "${1:0:5}" = "--no-" && _arg_verbose="off"
        ;;
      -V*)
        _arg_verbose="on"
        _next="${_key##-V}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-V" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -v|--version)
        echo $0 v0.1
        exit 0
        ;;
      -v*)
        echo $0 v0.1
        exit 0
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


handle_passed_args_count()
{
  local _required_args_string="'pod'"
  test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
  local _positional_name _shift_for=$1
  _positional_names="_arg_pod "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


POD_NAME=$_arg_pod
SOURCE_PATH=$_arg_local_dropbear_path
PAYLOAD_DIR=$_arg_remote_dropbear_dir
PAYLOAD_PATH="${PAYLOAD_DIR}/dropbear"
PORT=$_arg_bind_port
AUTHORIZED_KEYS_PATH=$_arg_authorized_keys_path
NAMESPACE=$_arg_namespace
SSH_PATH=$_arg_ssh_path

KUBECTL_CMD="kubectl"
AUTHORIZED_KEYS_DEST="${SSH_PATH}/authorized_keys"


if [ ! -z "$NAMESPACE" ];
then
    KUBECTL_CMD="${KUBECTL_CMD} -n ${NAMESPACE}"
fi


copy_binary() {
    $KUBECTL_CMD exec $POD_NAME ls $PAYLOAD_PATH > /dev/null 2>&1
    if [ $? -ne 0 ]
    then
        echo "Payload binary does not exist at $PAYLOAD_PATH. Uploading..."
        $KUBECTL_CMD exec $POD_NAME -- mkdir -p $PAYLOAD_DIR
        if [ $? -ne 0 ]
        then
            echo "Payload DIR $PAYLOAD_DIR could not be created. Aborting."
            exit 1
        fi
        $KUBECTL_CMD cp $SOURCE_PATH $POD_NAME:$PAYLOAD_PATH
        if [ $? -eq 0 ]
        then
            echo "Payload uploaded to $PAYLOAD_PATH!"
        else
            echo "Payload failed to upload. Aborting."
            cat << EOF

=================================================================================================
To obtain a static dropbear binary, you can run the following commands (requires Docker and Make):
> git clone https://github.com/ottoyiu/kubectl-sshd.git
> cd kubectl-sshd
> make bin/static-dropbear
> cp bin/static-dropbear .
=================================================================================================
EOF
            exit 1
        fi
    fi
}
copy_keys() {
    set -e
    if [ ! -f "$AUTHORIZED_KEYS_PATH" ]; then
        echo "Authorized Keys Path, $AUTHORIZED_KEYS_PATH, does not exist. Aborting."
        echo "To generate a new keypair, run the following command: ssh-keygen -t rsa -N '' -f id_rsa"
        exit 2
    fi
    $KUBECTL_CMD exec $POD_NAME -- mkdir -p $SSH_PATH
    $KUBECTL_CMD cp $AUTHORIZED_KEYS_PATH $POD_NAME:$AUTHORIZED_KEYS_DEST
    $KUBECTL_CMD exec $POD_NAME -- chmod 0600 -R $SSH_PATH
    $KUBECTL_CMD exec $POD_NAME -- chown root:root -R $SSH_PATH
    set +e
}
start_ssh_server() {
    set -e
    POD_IP=$($KUBECTL_CMD get pods $POD_NAME -o jsonpath='{.status.podIP}')
    echo "Starting dropbear SSH server in $POD_NAME. It is now accessible on $POD_IP (port $PORT)"
    $KUBECTL_CMD exec $POD_NAME -- mkdir -p /etc/dropbear
    $KUBECTL_CMD exec -it $POD_NAME -- $PAYLOAD_PATH -RFEs -p $PORT
    set +e
}

cleanup() {
    set -e
    echo "Cleanup Enabled. Initiating Cleanup"
    $KUBECTL_CMD exec $POD_NAME -- rm $AUTHORIZED_KEYS_DEST
    $KUBECTL_CMD exec $POD_NAME -- rm -rf /etc/dropbear
    $KUBECTL_CMD exec $POD_NAME -- rm $PAYLOAD_PATH
    set +e
}

if [ "$_arg_verbose" = on ]
then
    set -x
fi

copy_binary
copy_keys
start_ssh_server

if [ "$_arg_cleanup" = on ]
then
    cleanup
fi

# ] <-- needed because of Argbash
